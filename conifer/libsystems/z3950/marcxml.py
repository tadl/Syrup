from xml.etree import ElementTree

def marcxml_to_dictionary(rec, multiples=False):
    tree = ElementTree.fromstring(rec)
    if tree.tag == '{http://www.loc.gov/MARC21/slim}collection':
        # then we may have multiple records
        records = tree.findall('{http://www.loc.gov/MARC21/slim}record')
    elif tree.tag == '{http://www.loc.gov/MARC21/slim}record':
        records = [tree]
    else:
        return []
    out = []
    for r in records:
        dct = {}
        for df in r.findall('{http://www.loc.gov/MARC21/slim}datafield'):
            t = df.attrib['tag']
            for sf in df.findall('{http://www.loc.gov/MARC21/slim}subfield'):
                c = sf.attrib['code']
                v = sf.text or ''
                dct.setdefault(t+c, []).append(v)
        dct = dict((k,'\n'.join(v or [])) for k,v in dct.items())
        out.append(dct)
    if multiples is False:
        return out and out[0] or None
    else:
        return out

def marcxml_dictionary_to_dc(dct):
    """Take a dictionary generated by marcxml_to_dictionary, and
    extract some Dublin Core elements from it. Fixme, I'm sure this
    could be way improved."""
    out = {}
    meta = [('245a', 'dc:title'), ('100a', 'dc:creator'), ('260b', 'dc:publisher'),
            ('260c', 'dc:date'), ('700a', 'dc:contributor')]
    for marc, dc in meta:
        value = dct.get(marc)
        if value:
            out[dc] = value
    title = out.get('dc:title')
    if title:
        if '245b' in dct:
            title += (' %s' % dct['245b'])
        # if title ends with a single character, strip it. usually a
        # spurious punctuation character.
        if ' ' in title:
            init, last = title.rsplit(' ',1)
            if len(last) == 1:
                title = init
            out['dc:title'] = title
    return out

    
